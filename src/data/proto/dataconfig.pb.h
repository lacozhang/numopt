// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dataconfig.proto

#ifndef PROTOBUF_dataconfig_2eproto__INCLUDED
#define PROTOBUF_dataconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "util/proto/range.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_dataconfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsDataConfigImpl();
void InitDefaultsDataConfig();
void InitDefaultsHDFSConfigImpl();
void InitDefaultsHDFSConfig();
inline void InitDefaults() {
  InitDefaultsDataConfig();
  InitDefaultsHDFSConfig();
}
}  // namespace protobuf_dataconfig_2eproto
namespace mltools {
class DataConfig;
class DataConfigDefaultTypeInternal;
extern DataConfigDefaultTypeInternal _DataConfig_default_instance_;
class HDFSConfig;
class HDFSConfigDefaultTypeInternal;
extern HDFSConfigDefaultTypeInternal _HDFSConfig_default_instance_;
}  // namespace mltools
namespace mltools {

enum DataConfig_DataFormat {
  DataConfig_DataFormat_TEXT = 1,
  DataConfig_DataFormat_PROTO = 2,
  DataConfig_DataFormat_BIN = 3
};
bool DataConfig_DataFormat_IsValid(int value);
const DataConfig_DataFormat DataConfig_DataFormat_DataFormat_MIN = DataConfig_DataFormat_TEXT;
const DataConfig_DataFormat DataConfig_DataFormat_DataFormat_MAX = DataConfig_DataFormat_BIN;
const int DataConfig_DataFormat_DataFormat_ARRAYSIZE = DataConfig_DataFormat_DataFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataConfig_DataFormat_descriptor();
inline const ::std::string& DataConfig_DataFormat_Name(DataConfig_DataFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataConfig_DataFormat_descriptor(), value);
}
inline bool DataConfig_DataFormat_Parse(
    const ::std::string& name, DataConfig_DataFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataConfig_DataFormat>(
    DataConfig_DataFormat_descriptor(), name, value);
}
enum DataConfig_TextFormat {
  DataConfig_TextFormat_DENSE = 1,
  DataConfig_TextFormat_SPARSE = 2,
  DataConfig_TextFormat_SPARSE_BINARY = 3,
  DataConfig_TextFormat_ADFEA = 4,
  DataConfig_TextFormat_LIBSVM = 5,
  DataConfig_TextFormat_TERAFEA = 6,
  DataConfig_TextFormat_VW = 7,
  DataConfig_TextFormat_CRITEO = 8
};
bool DataConfig_TextFormat_IsValid(int value);
const DataConfig_TextFormat DataConfig_TextFormat_TextFormat_MIN = DataConfig_TextFormat_DENSE;
const DataConfig_TextFormat DataConfig_TextFormat_TextFormat_MAX = DataConfig_TextFormat_CRITEO;
const int DataConfig_TextFormat_TextFormat_ARRAYSIZE = DataConfig_TextFormat_TextFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataConfig_TextFormat_descriptor();
inline const ::std::string& DataConfig_TextFormat_Name(DataConfig_TextFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataConfig_TextFormat_descriptor(), value);
}
inline bool DataConfig_TextFormat_Parse(
    const ::std::string& name, DataConfig_TextFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataConfig_TextFormat>(
    DataConfig_TextFormat_descriptor(), name, value);
}
// ===================================================================

class DataConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mltools.DataConfig) */ {
 public:
  DataConfig();
  virtual ~DataConfig();

  DataConfig(const DataConfig& from);

  inline DataConfig& operator=(const DataConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataConfig(DataConfig&& from) noexcept
    : DataConfig() {
    *this = ::std::move(from);
  }

  inline DataConfig& operator=(DataConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataConfig* internal_default_instance() {
    return reinterpret_cast<const DataConfig*>(
               &_DataConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DataConfig* other);
  friend void swap(DataConfig& a, DataConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  DataConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DataConfig& from);
  void MergeFrom(const DataConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DataConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DataConfig_DataFormat DataFormat;
  static const DataFormat TEXT =
    DataConfig_DataFormat_TEXT;
  static const DataFormat PROTO =
    DataConfig_DataFormat_PROTO;
  static const DataFormat BIN =
    DataConfig_DataFormat_BIN;
  static inline bool DataFormat_IsValid(int value) {
    return DataConfig_DataFormat_IsValid(value);
  }
  static const DataFormat DataFormat_MIN =
    DataConfig_DataFormat_DataFormat_MIN;
  static const DataFormat DataFormat_MAX =
    DataConfig_DataFormat_DataFormat_MAX;
  static const int DataFormat_ARRAYSIZE =
    DataConfig_DataFormat_DataFormat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DataFormat_descriptor() {
    return DataConfig_DataFormat_descriptor();
  }
  static inline const ::std::string& DataFormat_Name(DataFormat value) {
    return DataConfig_DataFormat_Name(value);
  }
  static inline bool DataFormat_Parse(const ::std::string& name,
      DataFormat* value) {
    return DataConfig_DataFormat_Parse(name, value);
  }

  typedef DataConfig_TextFormat TextFormat;
  static const TextFormat DENSE =
    DataConfig_TextFormat_DENSE;
  static const TextFormat SPARSE =
    DataConfig_TextFormat_SPARSE;
  static const TextFormat SPARSE_BINARY =
    DataConfig_TextFormat_SPARSE_BINARY;
  static const TextFormat ADFEA =
    DataConfig_TextFormat_ADFEA;
  static const TextFormat LIBSVM =
    DataConfig_TextFormat_LIBSVM;
  static const TextFormat TERAFEA =
    DataConfig_TextFormat_TERAFEA;
  static const TextFormat VW =
    DataConfig_TextFormat_VW;
  static const TextFormat CRITEO =
    DataConfig_TextFormat_CRITEO;
  static inline bool TextFormat_IsValid(int value) {
    return DataConfig_TextFormat_IsValid(value);
  }
  static const TextFormat TextFormat_MIN =
    DataConfig_TextFormat_TextFormat_MIN;
  static const TextFormat TextFormat_MAX =
    DataConfig_TextFormat_TextFormat_MAX;
  static const int TextFormat_ARRAYSIZE =
    DataConfig_TextFormat_TextFormat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TextFormat_descriptor() {
    return DataConfig_TextFormat_descriptor();
  }
  static inline const ::std::string& TextFormat_Name(TextFormat value) {
    return DataConfig_TextFormat_Name(value);
  }
  static inline bool TextFormat_Parse(const ::std::string& name,
      TextFormat* value) {
    return DataConfig_TextFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string file = 3;
  int file_size() const;
  void clear_file();
  static const int kFileFieldNumber = 3;
  const ::std::string& file(int index) const;
  ::std::string* mutable_file(int index);
  void set_file(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_file(int index, ::std::string&& value);
  #endif
  void set_file(int index, const char* value);
  void set_file(int index, const char* value, size_t size);
  ::std::string* add_file();
  void add_file(const ::std::string& value);
  #if LANG_CXX11
  void add_file(::std::string&& value);
  #endif
  void add_file(const char* value);
  void add_file(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& file() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_file();

  // optional .mltools.PbRange range = 4;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 4;
  const ::mltools::PbRange& range() const;
  ::mltools::PbRange* release_range();
  ::mltools::PbRange* mutable_range();
  void set_allocated_range(::mltools::PbRange* range);

  // optional .mltools.HDFSConfig hdfs = 9;
  bool has_hdfs() const;
  void clear_hdfs();
  static const int kHdfsFieldNumber = 9;
  const ::mltools::HDFSConfig& hdfs() const;
  ::mltools::HDFSConfig* release_hdfs();
  ::mltools::HDFSConfig* mutable_hdfs();
  void set_allocated_hdfs(::mltools::HDFSConfig* hdfs);

  // optional bool ignore_feature_group = 5;
  bool has_ignore_feature_group() const;
  void clear_ignore_feature_group();
  static const int kIgnoreFeatureGroupFieldNumber = 5;
  bool ignore_feature_group() const;
  void set_ignore_feature_group(bool value);

  // optional bool shuffle = 8 [default = false];
  bool has_shuffle() const;
  void clear_shuffle();
  static const int kShuffleFieldNumber = 8;
  bool shuffle() const;
  void set_shuffle(bool value);

  // optional int32 replica = 10 [default = 1];
  bool has_replica() const;
  void clear_replica();
  static const int kReplicaFieldNumber = 10;
  ::google::protobuf::int32 replica() const;
  void set_replica(::google::protobuf::int32 value);

  // optional .mltools.DataConfig.DataFormat format = 1;
  bool has_format() const;
  void clear_format();
  static const int kFormatFieldNumber = 1;
  ::mltools::DataConfig_DataFormat format() const;
  void set_format(::mltools::DataConfig_DataFormat value);

  // optional .mltools.DataConfig.TextFormat text = 2;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  ::mltools::DataConfig_TextFormat text() const;
  void set_text(::mltools::DataConfig_TextFormat value);

  // optional int32 maximum_files_per_worker = 6 [default = -1];
  bool has_maximum_files_per_worker() const;
  void clear_maximum_files_per_worker();
  static const int kMaximumFilesPerWorkerFieldNumber = 6;
  ::google::protobuf::int32 maximum_files_per_worker() const;
  void set_maximum_files_per_worker(::google::protobuf::int32 value);

  // optional int32 maximum_examples_per_file = 7 [default = -1];
  bool has_maximum_examples_per_file() const;
  void clear_maximum_examples_per_file();
  static const int kMaximumExamplesPerFileFieldNumber = 7;
  ::google::protobuf::int32 maximum_examples_per_file() const;
  void set_maximum_examples_per_file(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mltools.DataConfig)
 private:
  void set_has_format();
  void clear_has_format();
  void set_has_text();
  void clear_has_text();
  void set_has_range();
  void clear_has_range();
  void set_has_ignore_feature_group();
  void clear_has_ignore_feature_group();
  void set_has_maximum_files_per_worker();
  void clear_has_maximum_files_per_worker();
  void set_has_maximum_examples_per_file();
  void clear_has_maximum_examples_per_file();
  void set_has_shuffle();
  void clear_has_shuffle();
  void set_has_hdfs();
  void clear_has_hdfs();
  void set_has_replica();
  void clear_has_replica();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> file_;
  ::mltools::PbRange* range_;
  ::mltools::HDFSConfig* hdfs_;
  bool ignore_feature_group_;
  bool shuffle_;
  ::google::protobuf::int32 replica_;
  int format_;
  int text_;
  ::google::protobuf::int32 maximum_files_per_worker_;
  ::google::protobuf::int32 maximum_examples_per_file_;
  friend struct ::protobuf_dataconfig_2eproto::TableStruct;
  friend void ::protobuf_dataconfig_2eproto::InitDefaultsDataConfigImpl();
};
// -------------------------------------------------------------------

class HDFSConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mltools.HDFSConfig) */ {
 public:
  HDFSConfig();
  virtual ~HDFSConfig();

  HDFSConfig(const HDFSConfig& from);

  inline HDFSConfig& operator=(const HDFSConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HDFSConfig(HDFSConfig&& from) noexcept
    : HDFSConfig() {
    *this = ::std::move(from);
  }

  inline HDFSConfig& operator=(HDFSConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HDFSConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HDFSConfig* internal_default_instance() {
    return reinterpret_cast<const HDFSConfig*>(
               &_HDFSConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(HDFSConfig* other);
  friend void swap(HDFSConfig& a, HDFSConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HDFSConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  HDFSConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HDFSConfig& from);
  void MergeFrom(const HDFSConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HDFSConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string home = 1;
  bool has_home() const;
  void clear_home();
  static const int kHomeFieldNumber = 1;
  const ::std::string& home() const;
  void set_home(const ::std::string& value);
  #if LANG_CXX11
  void set_home(::std::string&& value);
  #endif
  void set_home(const char* value);
  void set_home(const char* value, size_t size);
  ::std::string* mutable_home();
  ::std::string* release_home();
  void set_allocated_home(::std::string* home);

  // optional string ugi = 2;
  bool has_ugi() const;
  void clear_ugi();
  static const int kUgiFieldNumber = 2;
  const ::std::string& ugi() const;
  void set_ugi(const ::std::string& value);
  #if LANG_CXX11
  void set_ugi(::std::string&& value);
  #endif
  void set_ugi(const char* value);
  void set_ugi(const char* value, size_t size);
  ::std::string* mutable_ugi();
  ::std::string* release_ugi();
  void set_allocated_ugi(::std::string* ugi);

  // optional string namenode = 3;
  bool has_namenode() const;
  void clear_namenode();
  static const int kNamenodeFieldNumber = 3;
  const ::std::string& namenode() const;
  void set_namenode(const ::std::string& value);
  #if LANG_CXX11
  void set_namenode(::std::string&& value);
  #endif
  void set_namenode(const char* value);
  void set_namenode(const char* value, size_t size);
  ::std::string* mutable_namenode();
  ::std::string* release_namenode();
  void set_allocated_namenode(::std::string* namenode);

  // @@protoc_insertion_point(class_scope:mltools.HDFSConfig)
 private:
  void set_has_home();
  void clear_has_home();
  void set_has_ugi();
  void clear_has_ugi();
  void set_has_namenode();
  void clear_has_namenode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr home_;
  ::google::protobuf::internal::ArenaStringPtr ugi_;
  ::google::protobuf::internal::ArenaStringPtr namenode_;
  friend struct ::protobuf_dataconfig_2eproto::TableStruct;
  friend void ::protobuf_dataconfig_2eproto::InitDefaultsHDFSConfigImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DataConfig

// optional .mltools.DataConfig.DataFormat format = 1;
inline bool DataConfig::has_format() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataConfig::set_has_format() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataConfig::clear_has_format() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataConfig::clear_format() {
  format_ = 1;
  clear_has_format();
}
inline ::mltools::DataConfig_DataFormat DataConfig::format() const {
  // @@protoc_insertion_point(field_get:mltools.DataConfig.format)
  return static_cast< ::mltools::DataConfig_DataFormat >(format_);
}
inline void DataConfig::set_format(::mltools::DataConfig_DataFormat value) {
  assert(::mltools::DataConfig_DataFormat_IsValid(value));
  set_has_format();
  format_ = value;
  // @@protoc_insertion_point(field_set:mltools.DataConfig.format)
}

// optional .mltools.DataConfig.TextFormat text = 2;
inline bool DataConfig::has_text() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataConfig::set_has_text() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataConfig::clear_has_text() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataConfig::clear_text() {
  text_ = 1;
  clear_has_text();
}
inline ::mltools::DataConfig_TextFormat DataConfig::text() const {
  // @@protoc_insertion_point(field_get:mltools.DataConfig.text)
  return static_cast< ::mltools::DataConfig_TextFormat >(text_);
}
inline void DataConfig::set_text(::mltools::DataConfig_TextFormat value) {
  assert(::mltools::DataConfig_TextFormat_IsValid(value));
  set_has_text();
  text_ = value;
  // @@protoc_insertion_point(field_set:mltools.DataConfig.text)
}

// repeated string file = 3;
inline int DataConfig::file_size() const {
  return file_.size();
}
inline void DataConfig::clear_file() {
  file_.Clear();
}
inline const ::std::string& DataConfig::file(int index) const {
  // @@protoc_insertion_point(field_get:mltools.DataConfig.file)
  return file_.Get(index);
}
inline ::std::string* DataConfig::mutable_file(int index) {
  // @@protoc_insertion_point(field_mutable:mltools.DataConfig.file)
  return file_.Mutable(index);
}
inline void DataConfig::set_file(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mltools.DataConfig.file)
  file_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DataConfig::set_file(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mltools.DataConfig.file)
  file_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DataConfig::set_file(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  file_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mltools.DataConfig.file)
}
inline void DataConfig::set_file(int index, const char* value, size_t size) {
  file_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mltools.DataConfig.file)
}
inline ::std::string* DataConfig::add_file() {
  // @@protoc_insertion_point(field_add_mutable:mltools.DataConfig.file)
  return file_.Add();
}
inline void DataConfig::add_file(const ::std::string& value) {
  file_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mltools.DataConfig.file)
}
#if LANG_CXX11
inline void DataConfig::add_file(::std::string&& value) {
  file_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mltools.DataConfig.file)
}
#endif
inline void DataConfig::add_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  file_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mltools.DataConfig.file)
}
inline void DataConfig::add_file(const char* value, size_t size) {
  file_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mltools.DataConfig.file)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DataConfig::file() const {
  // @@protoc_insertion_point(field_list:mltools.DataConfig.file)
  return file_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DataConfig::mutable_file() {
  // @@protoc_insertion_point(field_mutable_list:mltools.DataConfig.file)
  return &file_;
}

// optional .mltools.PbRange range = 4;
inline bool DataConfig::has_range() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataConfig::set_has_range() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataConfig::clear_has_range() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mltools::PbRange& DataConfig::range() const {
  const ::mltools::PbRange* p = range_;
  // @@protoc_insertion_point(field_get:mltools.DataConfig.range)
  return p != NULL ? *p : *reinterpret_cast<const ::mltools::PbRange*>(
      &::mltools::_PbRange_default_instance_);
}
inline ::mltools::PbRange* DataConfig::release_range() {
  // @@protoc_insertion_point(field_release:mltools.DataConfig.range)
  clear_has_range();
  ::mltools::PbRange* temp = range_;
  range_ = NULL;
  return temp;
}
inline ::mltools::PbRange* DataConfig::mutable_range() {
  set_has_range();
  if (range_ == NULL) {
    range_ = new ::mltools::PbRange;
  }
  // @@protoc_insertion_point(field_mutable:mltools.DataConfig.range)
  return range_;
}
inline void DataConfig::set_allocated_range(::mltools::PbRange* range) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(range_);
  }
  if (range) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      range = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, range, submessage_arena);
    }
    set_has_range();
  } else {
    clear_has_range();
  }
  range_ = range;
  // @@protoc_insertion_point(field_set_allocated:mltools.DataConfig.range)
}

// optional bool ignore_feature_group = 5;
inline bool DataConfig::has_ignore_feature_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataConfig::set_has_ignore_feature_group() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataConfig::clear_has_ignore_feature_group() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataConfig::clear_ignore_feature_group() {
  ignore_feature_group_ = false;
  clear_has_ignore_feature_group();
}
inline bool DataConfig::ignore_feature_group() const {
  // @@protoc_insertion_point(field_get:mltools.DataConfig.ignore_feature_group)
  return ignore_feature_group_;
}
inline void DataConfig::set_ignore_feature_group(bool value) {
  set_has_ignore_feature_group();
  ignore_feature_group_ = value;
  // @@protoc_insertion_point(field_set:mltools.DataConfig.ignore_feature_group)
}

// optional int32 maximum_files_per_worker = 6 [default = -1];
inline bool DataConfig::has_maximum_files_per_worker() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DataConfig::set_has_maximum_files_per_worker() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DataConfig::clear_has_maximum_files_per_worker() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DataConfig::clear_maximum_files_per_worker() {
  maximum_files_per_worker_ = -1;
  clear_has_maximum_files_per_worker();
}
inline ::google::protobuf::int32 DataConfig::maximum_files_per_worker() const {
  // @@protoc_insertion_point(field_get:mltools.DataConfig.maximum_files_per_worker)
  return maximum_files_per_worker_;
}
inline void DataConfig::set_maximum_files_per_worker(::google::protobuf::int32 value) {
  set_has_maximum_files_per_worker();
  maximum_files_per_worker_ = value;
  // @@protoc_insertion_point(field_set:mltools.DataConfig.maximum_files_per_worker)
}

// optional int32 maximum_examples_per_file = 7 [default = -1];
inline bool DataConfig::has_maximum_examples_per_file() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DataConfig::set_has_maximum_examples_per_file() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DataConfig::clear_has_maximum_examples_per_file() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DataConfig::clear_maximum_examples_per_file() {
  maximum_examples_per_file_ = -1;
  clear_has_maximum_examples_per_file();
}
inline ::google::protobuf::int32 DataConfig::maximum_examples_per_file() const {
  // @@protoc_insertion_point(field_get:mltools.DataConfig.maximum_examples_per_file)
  return maximum_examples_per_file_;
}
inline void DataConfig::set_maximum_examples_per_file(::google::protobuf::int32 value) {
  set_has_maximum_examples_per_file();
  maximum_examples_per_file_ = value;
  // @@protoc_insertion_point(field_set:mltools.DataConfig.maximum_examples_per_file)
}

// optional bool shuffle = 8 [default = false];
inline bool DataConfig::has_shuffle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataConfig::set_has_shuffle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataConfig::clear_has_shuffle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataConfig::clear_shuffle() {
  shuffle_ = false;
  clear_has_shuffle();
}
inline bool DataConfig::shuffle() const {
  // @@protoc_insertion_point(field_get:mltools.DataConfig.shuffle)
  return shuffle_;
}
inline void DataConfig::set_shuffle(bool value) {
  set_has_shuffle();
  shuffle_ = value;
  // @@protoc_insertion_point(field_set:mltools.DataConfig.shuffle)
}

// optional .mltools.HDFSConfig hdfs = 9;
inline bool DataConfig::has_hdfs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataConfig::set_has_hdfs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataConfig::clear_has_hdfs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataConfig::clear_hdfs() {
  if (hdfs_ != NULL) hdfs_->Clear();
  clear_has_hdfs();
}
inline const ::mltools::HDFSConfig& DataConfig::hdfs() const {
  const ::mltools::HDFSConfig* p = hdfs_;
  // @@protoc_insertion_point(field_get:mltools.DataConfig.hdfs)
  return p != NULL ? *p : *reinterpret_cast<const ::mltools::HDFSConfig*>(
      &::mltools::_HDFSConfig_default_instance_);
}
inline ::mltools::HDFSConfig* DataConfig::release_hdfs() {
  // @@protoc_insertion_point(field_release:mltools.DataConfig.hdfs)
  clear_has_hdfs();
  ::mltools::HDFSConfig* temp = hdfs_;
  hdfs_ = NULL;
  return temp;
}
inline ::mltools::HDFSConfig* DataConfig::mutable_hdfs() {
  set_has_hdfs();
  if (hdfs_ == NULL) {
    hdfs_ = new ::mltools::HDFSConfig;
  }
  // @@protoc_insertion_point(field_mutable:mltools.DataConfig.hdfs)
  return hdfs_;
}
inline void DataConfig::set_allocated_hdfs(::mltools::HDFSConfig* hdfs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete hdfs_;
  }
  if (hdfs) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hdfs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hdfs, submessage_arena);
    }
    set_has_hdfs();
  } else {
    clear_has_hdfs();
  }
  hdfs_ = hdfs;
  // @@protoc_insertion_point(field_set_allocated:mltools.DataConfig.hdfs)
}

// optional int32 replica = 10 [default = 1];
inline bool DataConfig::has_replica() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataConfig::set_has_replica() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataConfig::clear_has_replica() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataConfig::clear_replica() {
  replica_ = 1;
  clear_has_replica();
}
inline ::google::protobuf::int32 DataConfig::replica() const {
  // @@protoc_insertion_point(field_get:mltools.DataConfig.replica)
  return replica_;
}
inline void DataConfig::set_replica(::google::protobuf::int32 value) {
  set_has_replica();
  replica_ = value;
  // @@protoc_insertion_point(field_set:mltools.DataConfig.replica)
}

// -------------------------------------------------------------------

// HDFSConfig

// optional string home = 1;
inline bool HDFSConfig::has_home() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HDFSConfig::set_has_home() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HDFSConfig::clear_has_home() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HDFSConfig::clear_home() {
  home_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_home();
}
inline const ::std::string& HDFSConfig::home() const {
  // @@protoc_insertion_point(field_get:mltools.HDFSConfig.home)
  return home_.GetNoArena();
}
inline void HDFSConfig::set_home(const ::std::string& value) {
  set_has_home();
  home_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mltools.HDFSConfig.home)
}
#if LANG_CXX11
inline void HDFSConfig::set_home(::std::string&& value) {
  set_has_home();
  home_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mltools.HDFSConfig.home)
}
#endif
inline void HDFSConfig::set_home(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_home();
  home_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mltools.HDFSConfig.home)
}
inline void HDFSConfig::set_home(const char* value, size_t size) {
  set_has_home();
  home_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mltools.HDFSConfig.home)
}
inline ::std::string* HDFSConfig::mutable_home() {
  set_has_home();
  // @@protoc_insertion_point(field_mutable:mltools.HDFSConfig.home)
  return home_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HDFSConfig::release_home() {
  // @@protoc_insertion_point(field_release:mltools.HDFSConfig.home)
  clear_has_home();
  return home_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HDFSConfig::set_allocated_home(::std::string* home) {
  if (home != NULL) {
    set_has_home();
  } else {
    clear_has_home();
  }
  home_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), home);
  // @@protoc_insertion_point(field_set_allocated:mltools.HDFSConfig.home)
}

// optional string ugi = 2;
inline bool HDFSConfig::has_ugi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HDFSConfig::set_has_ugi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HDFSConfig::clear_has_ugi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HDFSConfig::clear_ugi() {
  ugi_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ugi();
}
inline const ::std::string& HDFSConfig::ugi() const {
  // @@protoc_insertion_point(field_get:mltools.HDFSConfig.ugi)
  return ugi_.GetNoArena();
}
inline void HDFSConfig::set_ugi(const ::std::string& value) {
  set_has_ugi();
  ugi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mltools.HDFSConfig.ugi)
}
#if LANG_CXX11
inline void HDFSConfig::set_ugi(::std::string&& value) {
  set_has_ugi();
  ugi_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mltools.HDFSConfig.ugi)
}
#endif
inline void HDFSConfig::set_ugi(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ugi();
  ugi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mltools.HDFSConfig.ugi)
}
inline void HDFSConfig::set_ugi(const char* value, size_t size) {
  set_has_ugi();
  ugi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mltools.HDFSConfig.ugi)
}
inline ::std::string* HDFSConfig::mutable_ugi() {
  set_has_ugi();
  // @@protoc_insertion_point(field_mutable:mltools.HDFSConfig.ugi)
  return ugi_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HDFSConfig::release_ugi() {
  // @@protoc_insertion_point(field_release:mltools.HDFSConfig.ugi)
  clear_has_ugi();
  return ugi_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HDFSConfig::set_allocated_ugi(::std::string* ugi) {
  if (ugi != NULL) {
    set_has_ugi();
  } else {
    clear_has_ugi();
  }
  ugi_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ugi);
  // @@protoc_insertion_point(field_set_allocated:mltools.HDFSConfig.ugi)
}

// optional string namenode = 3;
inline bool HDFSConfig::has_namenode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HDFSConfig::set_has_namenode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HDFSConfig::clear_has_namenode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HDFSConfig::clear_namenode() {
  namenode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_namenode();
}
inline const ::std::string& HDFSConfig::namenode() const {
  // @@protoc_insertion_point(field_get:mltools.HDFSConfig.namenode)
  return namenode_.GetNoArena();
}
inline void HDFSConfig::set_namenode(const ::std::string& value) {
  set_has_namenode();
  namenode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mltools.HDFSConfig.namenode)
}
#if LANG_CXX11
inline void HDFSConfig::set_namenode(::std::string&& value) {
  set_has_namenode();
  namenode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mltools.HDFSConfig.namenode)
}
#endif
inline void HDFSConfig::set_namenode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_namenode();
  namenode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mltools.HDFSConfig.namenode)
}
inline void HDFSConfig::set_namenode(const char* value, size_t size) {
  set_has_namenode();
  namenode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mltools.HDFSConfig.namenode)
}
inline ::std::string* HDFSConfig::mutable_namenode() {
  set_has_namenode();
  // @@protoc_insertion_point(field_mutable:mltools.HDFSConfig.namenode)
  return namenode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HDFSConfig::release_namenode() {
  // @@protoc_insertion_point(field_release:mltools.HDFSConfig.namenode)
  clear_has_namenode();
  return namenode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HDFSConfig::set_allocated_namenode(::std::string* namenode) {
  if (namenode != NULL) {
    set_has_namenode();
  } else {
    clear_has_namenode();
  }
  namenode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), namenode);
  // @@protoc_insertion_point(field_set_allocated:mltools.HDFSConfig.namenode)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mltools

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mltools::DataConfig_DataFormat> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mltools::DataConfig_DataFormat>() {
  return ::mltools::DataConfig_DataFormat_descriptor();
}
template <> struct is_proto_enum< ::mltools::DataConfig_TextFormat> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mltools::DataConfig_TextFormat>() {
  return ::mltools::DataConfig_TextFormat_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dataconfig_2eproto__INCLUDED
